import sys, os

def options(opt):
        opt.load('compiler_c')

def external_cmd(conf, cmd, cwd):
    try:
        return conf.cmd_and_log(cmd, cwd=cwd)
    except Exception as e:
        from waflib import Logs
        Logs.info('cmd failed! ' + str(e))
        Logs.info(e.stdout)
        Logs.info(e.stderr)
        Logs.info(dir(e))
        return 0

def get_contrib(conf,c):
    print "Pulling via git %s..." % c[1]
    conf.env.CONTRIB_PATH = './'
    conf.exec_command("git clone %s %s" % (c[1],c[0],))
    conf.exec_command("git pull %s" % c[1], cwd=c[0])

def configure(conf):

    conf.load('compiler_c')
    conf.load('clib')

    print conf.clib_c_files('strndup')
    print conf.clib_h_files('strndup')
    print conf.clib_info('strndup')

    conf.env.CONTRIB_PATH = './'



    if sys.platform == 'win32':
        conf.check_cc(lib='ws2_32')
        conf.check_cc(lib='psapi')

    conf.env.STDLIBPATH = ['.']
#    conf.check_cc(lib='uv')

    conf.find_program("git")
    #conf.find_program("automake")
    #conf.find_program("glibtoolize")

    # Install and build libuv
    print "Configuring libuv (autogen.sh)"
#    if sys.platform == 'darwin':
#        conf.exec_command('mkdir -p build', cwd='libuv')
#        conf.exec_command('git clone https://git.chromium.org/external/gyp.git build/gyp', cwd='libuv')
#        conf.exec_command('git pull https://git.chromium.org/external/gyp.git', cwd='libuv/build/gyp')
#        external_cmd(conf, './gyp_uv.py -f xcode', cwd='libuv')
#        external_cmd(conf, 'xcodebuild -ARCHS="x86_64" -project uv.xcodeproj -configuration Release -target All', cwd='libuv')
#        conf.exec_command("cp libuv/build/Release/libuv.a build/")
#    else:
#        conf.exec_command("sh autogen.sh", cwd="libuv")
#        print "Configuring libuv (configure)"
#        conf.exec_command("sh configure", cwd="libuv")
#        print "Building libuv.a"
#        conf.exec_command("make", cwd="libuv")
#        conf.exec_command("mkdir build")
#        conf.exec_command("cp libuv/.libs/libuv.a build/")

def unit_test(bld, src, ccflag=None):
    # collect tests into one area
    bld(rule='sh ../make-tests.sh ../tests/'+src+' > ${TGT}', target="tests/t_"+src)

    libs = []

    # build the test program
    bld.program(
        source=[
            "tests/"+src,
            "tests/t_"+src,
            'tests/CuTest.c',
            bld.env.CONTRIB_PATH+"CBitfield/bitfield.c",
        ],
        target=src[:-2],
        cflags=[
            '-g',
            '-Werror',
        ],
        use='yabbt',
        lib = libs,
        unit_test='yes',
        includes=[
            "./include",
            bld.env.CONTRIB_PATH+"CBitfield"
        ]
        )

    # run the test
    if sys.platform == 'win32':
        bld(rule='${SRC}',source=src[:-2]+'.exe')
    else:
        bld(rule='export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:. && ./${SRC}', source=src[:-2])

def scenario_test(bld, src, ccflag=None):
    src = "tests/"+src
    #bld(rule='cp ../tests/make-tests.sh .')
    #bld(rule='echo $(pwd)')
    #bld(rule='echo $(pwd) && cp %s .' % src)
    # collect tests into one area
    bld(rule='sh ../make-tests.sh ../'+src+' > ${TGT}', target=src+".autogenerated.c")

    libs = []
    bld.program(
        source=[
            src,
            src+".autogenerated.c",
            "tests/CuTest.c",
            "src/networkfuncs_mock.c",
            "src/mt19937ar.c",
            "tests/mock_torrent.c",
            "tests/mock_client.c",
            bld.env.CONTRIB_PATH+"CBipBuffer/bipbuffer.c",
            bld.env.CONTRIB_PATH+"PeerWireProtocol/pwp_handshaker.c"
            ],
        stlibpath = ['libuv','.'],
        target=src[:-2],
        cflags=[
            '-g',
            '-Werror',
            '-Werror=unused-variable',
            '-Werror=uninitialized',
            '-Werror=return-type',
            ],
        lib = libs,
        unit_test='yes',
        includes=[
            "./include",
            "./tests",
            bld.env.CONTRIB_PATH+"CBitfield",
            bld.env.CONTRIB_PATH+"CSimpleBitstream",
            bld.env.CONTRIB_PATH+"PeerWireProtocol",
            bld.env.CONTRIB_PATH+"CConfig-re",
            bld.env.CONTRIB_PATH+"CBTTrackerClient",
            bld.env.CONTRIB_PATH+"CHeaplessBencodeReader",
            bld.env.CONTRIB_PATH+"CTorrentFileReader",
            bld.env.CONTRIB_PATH+"CHashMapViaLinkedList",
            bld.env.CONTRIB_PATH+"CBipBuffer",
           ], 
        use='yabbt')

    # run the test
    if sys.platform == 'win32':
        bld(rule='${SRC}',source=src[:-2]+'.exe')
    else:
        bld(rule='export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:. && ./${SRC}',source=src[:-2])
        #bld(rule='pwd && export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:. && ./'+src[:-2])

def build(bld):
    cp = bld.env.CONTRIB_PATH


    print bld.clib_c_files('bitfield')
    print bld.clib_h_files('bitfield')

    print cp

    # Copy libuv.a to build/
    #bld(rule='cp '+cp+'/libuv/.libs/libuv.a .', always=True)#, target="libuv.a")

    if sys.platform == 'win32':
        platform = '-DWIN32'
    elif sys.platform == 'linux2':
        platform = '-DLINUX'
    else:
        platform = ''

    libs = []

    libyabtorrent_src = [
        "src/bt_blacklist.c",
        "src/bt_choker_leecher.c",
        "src/bt_choker_seeder.c",
        "src/bt_diskcache.c",
        "src/bt_diskmem.c",
        "src/bt_download_manager.c",
        "src/bt_filedumper.c",
        "src/bt_peer_manager.c",
        "src/bt_piece.c",
        "src/bt_piece_db.c",
        "src/bt_selector_random.c",
        "src/bt_selector_rarestfirst.c",
        "src/bt_selector_sequential.c",
        "src/bt_util.c",
        "src/bt_sha1.c", ] +\
        bld.clib_c_files([
        'array-avl-tree',
        'asprintf',
        'bag',
        'bitfield',
        'bitstream',
        'chunky-bar',
        'config-re',
        'event-timer',
        'file2str',
        'heap',
        'heapless-bencode',
        'linked-list-hashmap',
        'linked-list-queue',
        'meanqueue',
        'peer-wire-protocol',
        'pseudolru',
        'sha1',
        'strndup',
        'stubfile',
        'torrent-file-reader',
        ])

    bld.shlib(
        source=libyabtorrent_src,
        #use='config',
        target='yabbt',
        lib = libs,
        includes=\
            [ './include', ] +\ 
            bld.clib_paths([
                'array-avl-tree',
                'asprintf',
                'bag',
                'bipbuffer',
                'bitfield',
                'bitstream',
                'chunkybar',
                'config-re',
                'event-timer',
                'heap',
                'heapless-bencode',
                'linked-list-hashmap',
                'linked-list-queue',
                'meanqueue',
                'pseudo-lru',
                'pwp',
                'strndup',
                'stubfile',
                'tracker-client',
               ]), 
        cflags=[
            '-Werror',
            '-Werror=format',
            '-Werror=int-to-pointer-cast',
            '-Qunused-arguments',
            '-g',
            platform,
            '-Werror=unused-variable',
            '-Werror=return-type',
            '-Werror=uninitialized',
            '-Werror=pointer-to-int-cast',
            '-Wcast-align'],
        )

    #unit_test(bld,"test_bt.c")
    #unit_test(bld,"test_download_manager.c")
    #unit_test(bld,"test_peer_manager.c")
    #unit_test(bld,'test_choker_leecher.c')
    #unit_test(bld,'test_choker_seeder.c')
    #unit_test(bld,'test_selector_rarestfirst.c')
    #unit_test(bld,'test_selector_random.c')
    #unit_test(bld,'test_selector_sequential.c')
    #unit_test(bld,'test_piece.c',ccflag='-I../'+cp+"CBitfield")
    #unit_test(bld,'test_piece_db.c')
    #unit_test(bld,'test_blacklist.c')
    #scenario_test(bld,'test_scenario_shares_all_pieces.c')
    #scenario_test(bld,'test_scenario_shares_all_pieces_between_each_other.c')
    #scenario_test(bld,'test_scenario_share_20_pieces.c')
    #scenario_test(bld,'test_scenario_three_peers_share_all_pieces_between_each_other.c')

    libs = ['yabbt','uv']
    if sys.platform == 'win32':
        libs += ['ws2_32']
        libs += ['psapi']
        libs += ['Iphlpapi']
    else:
        libs += ['dl']
        libs += ['rt']
        libs += ['pthread']

    yabtorrent_src = [
            'src/yabtorrent.c',
            "src/network_adapter_libuv.c",
#            cp+"CTrackerClient/url_encoder.c",
#            cp+"CTrackerClient/tracker_http.c",
#            cp+"CTrackerClient/tracker_client.c",
#            cp+"CTrackerClient/tracker_http_response_reader.c",
#            cp+"CTrackerClient/http-parser/http_parser.c",
            ] +\
            bld.clib_files([
                'mt19937ar',
                'bipbuffer',
                'tracker-client',
                'http-parser',
            ])
    yabtorrent_src

    bld.program(
        source=yabtorrent_src,
        target='yabtorrent',
        cflags=[
            '-g',
            '-Werror',
            '-Werror=uninitialized',
            '-Werror=pointer-to-int-cast',
            '-Werror=return-type'
            ],
        stlibpath = ['./libuv','.'],
        lib = libs,
        includes=[
            './include',
            './libuv/include'] +\
            bld.clib_paths([
                'asprintf',
                'bipbuffer',
                'config-re',
                'heapless-bencode',
                'http-parser',
                'linked-list-hashmap',
                'linked-list-queue',
                'pwp',
                'strndup',
                'tracker-client',
           ]))

